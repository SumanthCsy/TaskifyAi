import pptxgen from 'pptxgenjs';
import { Prompt } from '@shared/schema';

/**
 * Generate a PowerPoint presentation from a prompt content
 * @param prompt The prompt to convert
 * @returns Buffer containing the generated PowerPoint file
 */
export async function generatePptFromPrompt(prompt: Prompt): Promise<Buffer> {
  // Create a new presentation
  const pres = new pptxgen();
  
  // Add metadata
  pres.author = 'AI Information Tool';
  pres.company = 'AI Insights';
  pres.subject = prompt.title;
  pres.title = prompt.title;
  
  // Set default slide options
  pres.layout = 'LAYOUT_WIDE';
  pres.theme = {
    headFontFace: 'Arial',
    bodyFontFace: 'Arial'
  };
  
  // Title slide
  const titleSlide = pres.addSlide();
  titleSlide.background = { color: 'F5F5F5' };
  
  titleSlide.addText(prompt.title, {
    x: 0.5,
    y: 2.0,
    w: '90%',
    h: 1.5,
    align: 'center',
    fontSize: 44,
    bold: true,
    color: '1565C0'
  });
  
  titleSlide.addText('Generated by AI Information Tool', {
    x: 0.5,
    y: 4.0,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 20,
    color: '546E7A'
  });
  
  const dateStr = new Date(prompt.createdAt).toLocaleDateString();
  titleSlide.addText(`Created: ${dateStr}`, {
    x: 0.5,
    y: 5.0,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 14,
    color: '78909C'
  });
  
  // Introduction slide
  const introSlide = pres.addSlide();
  introSlide.addText('Introduction', {
    x: 0.5,
    y: 0.5,
    w: '90%',
    h: 0.8,
    fontSize: 32,
    bold: true,
    color: '1565C0'
  });
  
  introSlide.addText('Original Prompt:', {
    x: 0.5,
    y: 1.5,
    w: '90%',
    h: 0.5,
    fontSize: 16,
    bold: true
  });
  
  introSlide.addText(prompt.prompt, {
    x: 0.5,
    y: 2.0,
    w: '90%',
    h: 1.0,
    fontSize: 16,
    italic: true,
    color: '546E7A'
  });
  
  // Parse content (assuming markdown format)
  const content = prompt.content;
  const lines = content.split('\n');
  
  let currentSection = '';
  let currentContent = '';
  let currentPoints: string[] = [];
  let isList = false;
  
  for (const line of lines) {
    // Skip title which we already used
    if (line.startsWith('# ') && line.substring(2).trim() === prompt.title) {
      continue;
    }
    
    // Check if line is a major heading
    if (line.startsWith('# ')) {
      // Process previous section if exists
      if (currentSection && (currentContent || currentPoints.length > 0)) {
        addContentSlide(pres, currentSection, currentContent, currentPoints);
      }
      
      // Start new section
      currentSection = line.replace('# ', '');
      currentContent = '';
      currentPoints = [];
      isList = false;
    } 
    // Check if line is a sub-heading
    else if (line.startsWith('## ')) {
      // Process previous section if exists
      if (currentSection && (currentContent || currentPoints.length > 0)) {
        addContentSlide(pres, currentSection, currentContent, currentPoints);
      }
      
      // Start new section
      currentSection = line.replace('## ', '');
      currentContent = '';
      currentPoints = [];
      isList = false;
    }
    // Check if line is a list item
    else if (line.trim().startsWith('- ') || line.trim().match(/^\d+\.\s/)) {
      // If we were previously building content, add it
      if (!isList && currentContent.trim()) {
        addContentSlide(pres, currentSection, currentContent.trim(), []);
        currentContent = '';
      }
      
      // Add to current list of points
      const pointText = line.trim().replace(/^-\s|\d+\.\s/, '');
      currentPoints.push(pointText);
      isList = true;
    }
    // Regular content
    else if (line.trim() !== '') {
      // If we were previously building a list, add it
      if (isList && currentPoints.length > 0) {
        addContentSlide(pres, currentSection, '', currentPoints);
        currentPoints = [];
      }
      
      // Add to current content
      currentContent += line + '\n';
      isList = false;
    }
  }
  
  // Add final section if exists
  if (currentSection && (currentContent || currentPoints.length > 0)) {
    addContentSlide(pres, currentSection, currentContent, currentPoints);
  }
  
  // Ending slide
  const endingSlide = pres.addSlide();
  endingSlide.background = { color: 'F5F5F5' };
  
  endingSlide.addText('Thank You!', {
    x: 0.5,
    y: 2.0,
    w: '90%',
    h: 1.5,
    align: 'center',
    fontSize: 44,
    bold: true,
    color: '1565C0'
  });
  
  endingSlide.addText('Generated by AI Information Tool', {
    x: 0.5,
    y: 4.0,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 20,
    color: '546E7A'
  });
  
  // Export to Buffer
  const data = await pres.write({ outputType: 'nodebuffer' }) as any;
  return Buffer.from(data);
}

/**
 * Helper function to add a content slide
 */
function addContentSlide(
  pres: pptxgen, 
  title: string, 
  content: string,
  bulletPoints: string[]
) {
  const slide = pres.addSlide();
  
  // Add title
  slide.addText(title, {
    x: 0.5,
    y: 0.5,
    w: '90%',
    h: 0.8,
    fontSize: 28,
    bold: true,
    color: '1565C0'
  });
  
  // Add content text if exists
  if (content && content.trim() !== '') {
    slide.addText(content.trim(), {
      x: 0.5,
      y: 1.5,
      w: '90%',
      h: 4.5,
      fontSize: 16,
      color: '333333',
      breakLine: true
    });
  }
  
  // Add bullet points if exist
  if (bulletPoints.length > 0) {
    slide.addText(bulletPoints.map(point => ({ text: point, bullet: true })), {
      x: 0.5,
      y: content ? 3.5 : 1.5,
      w: '90%',
      h: 4.5,
      fontSize: 16,
      color: '333333',
      breakLine: true,
      bullet: { type: 'bullet' }
    });
  }
}

/**
 * Generate a PowerPoint presentation from a report content
 * @param title The report title
 * @param content The report content
 * @returns Buffer containing the generated PowerPoint file
 */
export async function generatePptFromReport(title: string, content: string): Promise<Buffer> {
  // Create a new presentation
  const pres = new pptxgen();
  
  // Add metadata
  pres.author = 'Taskify AI';
  pres.company = 'Taskify AI';
  pres.subject = title;
  pres.title = title;
  
  // Choose a random theme from available themes
  const themes = [
    {
      name: 'MODERN',
      titleColor: '4040FF', // Blue
      accentColor: '444AFF',
      bgColor: 'FFFFFF',
      slideNumber: true,
      fontFace: 'Calibri'
    },
    {
      name: 'GRADIENT',
      titleColor: '7030A0', // Purple
      accentColor: '9966CC',
      bgGradient: { type: 'linear', stops: [{color: 'F4F5FF', position: 0}, {color: 'E6E8FF', position: 100}] },
      slideNumber: true,
      fontFace: 'Segoe UI'
    },
    {
      name: 'MINIMAL',
      titleColor: '333333', // Dark Gray
      accentColor: '666666',
      bgColor: 'FFFFFF',
      slideNumber: false,
      fontFace: 'Arial'
    },
    {
      name: 'VIBRANT',
      titleColor: '00838F', // Teal
      accentColor: '00ACC1',
      bgColor: 'F5F5F5',
      slideNumber: true,
      fontFace: 'Verdana'
    },
    {
      name: 'CORPORATE',
      titleColor: '0D47A1', // Deep Blue
      accentColor: '1976D2',
      bgColor: 'FFFFFF',
      slideNumber: true,
      fontFace: 'Roboto'
    }
  ];
  
  // Select a theme (based on title to keep it consistent)
  const themeIndex = Math.abs(title.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % themes.length;
  const selectedTheme = themes[themeIndex];
  
  // Apply theme settings
  pres.layout = 'LAYOUT_WIDE';
  pres.theme = {
    headFontFace: selectedTheme.fontFace,
    bodyFontFace: selectedTheme.fontFace
  };
  
  // Enable slide numbers if the theme requires them
  if (selectedTheme.slideNumber) {
    pres.defineSlideMaster({
      title: 'MASTER_SLIDE',
      slideNumber: { x: '90%', y: '95%', fontFace: selectedTheme.fontFace, fontSize: 10, color: selectedTheme.accentColor }
    });
  }
  
  // Title slide with more modern design
  const titleSlide = pres.addSlide();
  
  // Set background based on theme
  if (selectedTheme.bgGradient) {
    titleSlide.background = { gradient: selectedTheme.bgGradient };
  } else {
    titleSlide.background = { color: selectedTheme.bgColor };
  }
  
  // Add design element - shape on the left
  titleSlide.addShape('RECTANGLE', { 
    x: 0, y: 0, w: 2, h: '100%', 
    fill: { color: selectedTheme.accentColor } 
  });
  
  // Add title with more prominence
  titleSlide.addText(title, {
    x: 2.5,
    y: 1.5,
    w: '70%',
    h: 1.8,
    fontSize: 44,
    bold: true,
    color: selectedTheme.titleColor
  });
  
  // Add subtitle with styling
  titleSlide.addText('Executive Summary', {
    x: 2.5,
    y: 3.3,
    w: '70%',
    h: 0.6,
    fontSize: 24,
    bold: false,
    italic: true,
    color: selectedTheme.accentColor
  });
  
  // Add decorative line
  titleSlide.addShape('LINE', {
    x: 2.5,
    y: 4.0,
    w: 3,
    h: 0,
    line: { color: selectedTheme.accentColor, width: 2 }
  });
  
  // Add date and generated info
  const dateStr = new Date().toLocaleDateString();
  titleSlide.addText(`Generated by Taskify AI • ${dateStr}`, {
    x: 2.5,
    y: 5.0,
    w: '70%',
    h: 0.4,
    fontSize: 14,
    color: selectedTheme.accentColor
  });
  
  // Extract table of contents from headings
  const lines = content.split('\n');
  const tableOfContents: string[] = [];
  let sectionCount = 0;
  let toc = '';
  
  // Table of contents slide
  const tocSlide = pres.addSlide();
  
  // Set background based on theme
  if (selectedTheme.bgGradient) {
    tocSlide.background = { gradient: selectedTheme.bgGradient };
  } else {
    tocSlide.background = { color: selectedTheme.bgColor };
  }
  
  // Add title for table of contents
  tocSlide.addText('Table of Contents', {
    x: 0.5,
    y: 0.5,
    w: '90%',
    h: 0.8,
    fontSize: 32,
    bold: true,
    color: selectedTheme.titleColor
  });
  
  // Extract headings for TOC
  for (const line of lines) {
    if (line.startsWith('# ') && !line.substring(2).trim().includes(title)) {
      sectionCount++;
      const heading = line.replace('# ', '').trim();
      tableOfContents.push(heading);
      
      // Add to TOC slide with section numbers
      tocSlide.addText(`${sectionCount}. ${heading}`, {
        x: 1,
        y: 1.5 + (sectionCount - 1) * 0.5,
        w: '90%',
        h: 0.4,
        fontSize: 18,
        color: selectedTheme.accentColor,
        bullet: { type: 'number', style: numberedListStyle(sectionCount), color: selectedTheme.titleColor }
      });
    }
  }
  
  // Add subtitle to TOC
  tocSlide.addText(`Explore these ${sectionCount} sections to learn about ${title}`, {
    x: 0.5,
    y: 1.0,
    w: '90%',
    h: 0.4,
    fontSize: 16,
    italic: true,
    color: selectedTheme.accentColor
  });
  
  // Parse the rest of the content
  let currentSection = '';
  let currentContent = '';
  let currentPoints: string[] = [];
  let isList = false;
  let slideCounter = 0;
  
  // Process markdown content into slides
  for (const line of lines) {
    // Skip title which we already used
    if (line.startsWith('# ') && line.substring(2).trim() === title) {
      continue;
    }
    
    // Check if line is a major heading
    if (line.startsWith('# ')) {
      // Process previous section if exists
      if (currentSection && (currentContent || currentPoints.length > 0)) {
        slideCounter++;
        addEnhancedContentSlide(pres, currentSection, currentContent, currentPoints, selectedTheme, slideCounter);
      }
      
      // Start new section
      currentSection = line.replace('# ', '');
      currentContent = '';
      currentPoints = [];
      isList = false;
    } 
    // Check if line is a sub-heading
    else if (line.startsWith('## ')) {
      // Process previous section if exists
      if (currentSection && (currentContent || currentPoints.length > 0)) {
        slideCounter++;
        addEnhancedContentSlide(pres, currentSection, currentContent, currentPoints, selectedTheme, slideCounter);
      }
      
      // Start new section
      currentSection = line.replace('## ', '');
      currentContent = '';
      currentPoints = [];
      isList = false;
    }
    // Check if line is a list item
    else if (line.trim().startsWith('- ') || line.trim().startsWith('* ') || line.trim().match(/^\d+\.\s/)) {
      // If we were previously building content, add it
      if (!isList && currentContent.trim()) {
        slideCounter++;
        addEnhancedContentSlide(pres, currentSection, currentContent.trim(), [], selectedTheme, slideCounter);
        currentContent = '';
      }
      
      // Add to current list of points
      const pointText = line.trim().replace(/^[-*]\s|\d+\.\s/, '');
      currentPoints.push(pointText);
      isList = true;
    }
    // Regular content
    else if (line.trim() !== '') {
      // If we were previously building a list, add it
      if (isList && currentPoints.length > 0) {
        slideCounter++;
        addEnhancedContentSlide(pres, currentSection, '', currentPoints, selectedTheme, slideCounter);
        currentPoints = [];
      }
      
      // Add to current content
      currentContent += line + '\n';
      isList = false;
    }
  }
  
  // Add final section if exists
  if (currentSection && (currentContent || currentPoints.length > 0)) {
    slideCounter++;
    addEnhancedContentSlide(pres, currentSection, currentContent, currentPoints, selectedTheme, slideCounter);
  }
  
  // Ending slide with theme styling
  const endingSlide = pres.addSlide();
  
  // Set background based on theme
  if (selectedTheme.bgGradient) {
    endingSlide.background = { gradient: selectedTheme.bgGradient };
  } else {
    endingSlide.background = { color: selectedTheme.bgColor };
  }
  
  // Add design element - circles or shapes for visual interest
  if (selectedTheme.name === 'VIBRANT' || selectedTheme.name === 'GRADIENT') {
    // Add decorative elements
    for (let i = 0; i < 5; i++) {
      endingSlide.addShape('OVAL', {
        x: 8 + (i * 0.2),
        y: i * 1.2,
        w: 0.5,
        h: 0.5,
        fill: { color: adjustColor(selectedTheme.accentColor, 20 * i) },
        opacity: 0.7
      });
    }
  }
  
  // Add Thank You message
  endingSlide.addText('Thank You!', {
    x: 0.5,
    y: 2.0,
    w: '90%',
    h: 1.5,
    align: 'center',
    fontSize: 50,
    bold: true,
    color: selectedTheme.titleColor
  });
  
  // Add contact info
  endingSlide.addText('For more information, visit sumanthcsy.netlify.app', {
    x: 0.5,
    y: 4.0,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 20,
    color: selectedTheme.accentColor
  });
  
  // Add Taskify AI branding
  endingSlide.addText('Generated by Taskify AI • The Future of Content Creation', {
    x: 0.5,
    y: 5.0,
    w: '90%',
    h: 0.5,
    align: 'center',
    fontSize: 14,
    bold: true,
    color: selectedTheme.accentColor
  });
  
  // Export to Buffer
  const data = await pres.write({ outputType: 'nodebuffer' }) as any;
  return Buffer.from(data);
}

/**
 * Creates an enhanced content slide with better design
 */
function addEnhancedContentSlide(
  pres: pptxgen, 
  title: string, 
  content: string,
  bulletPoints: string[],
  theme: any,
  slideNumber: number
) {
  const slide = pres.addSlide();
  
  // Apply theme background
  if (theme.bgGradient) {
    slide.background = { gradient: theme.bgGradient };
  } else {
    slide.background = { color: theme.bgColor };
  }
  
  // Add visual elements based on theme
  if (theme.name === 'MODERN') {
    // Add accent bar at the top
    slide.addShape('RECTANGLE', {
      x: 0, y: 0, w: '100%', h: 0.25, 
      fill: { color: theme.accentColor }
    });
  } else if (theme.name === 'GRADIENT') {
    // Add a subtle shape in the corner
    slide.addShape('ROUNDED_RECTANGLE', {
      x: 8.5, y: 0.2, w: 1, h: 1, 
      fill: { color: theme.accentColor },
      opacity: 0.3
    });
  } else if (theme.name === 'VIBRANT') {
    // Add circle accent
    slide.addShape('OVAL', {
      x: -0.5, y: 5, w: 1.5, h: 1.5, 
      fill: { color: theme.accentColor },
      opacity: 0.4
    });
  }
  
  // Add section number indicator
  if (slideNumber > 2) { // Skip TOC and title slide
    slide.addText(`${slideNumber-2}`, {
      x: 0.3,
      y: 0.3,
      w: 0.5,
      h: 0.5,
      fontSize: 16,
      bold: true,
      color: 'FFFFFF',
      fill: { color: theme.accentColor },
      align: 'center',
      shape: 'OVAL'
    });
  }
  
  // Add title with styling
  slide.addText(title, {
    x: 0.5,
    y: 0.5,
    w: '90%',
    h: 0.8,
    fontSize: 32,
    bold: true,
    color: theme.titleColor
  });
  
  // Add divider line for visual separation
  slide.addShape('LINE', {
    x: 0.5,
    y: 1.4,
    w: 4,
    h: 0,
    line: { color: theme.accentColor, width: 1.5 }
  });
  
  // Add content text if exists
  if (content && content.trim() !== '') {
    // Try to extract first paragraph as highlight if content is long
    const paragraphs = content.split('\n\n');
    const firstParagraph = paragraphs[0];
    const restContent = paragraphs.slice(1).join('\n\n');
    
    if (paragraphs.length > 1 && firstParagraph.length < 200) {
      // First paragraph as highlight
      slide.addText(firstParagraph.trim(), {
        x: 0.5,
        y: 1.6,
        w: '90%',
        h: 1.0,
        fontSize: 18,
        italic: true,
        color: theme.accentColor
      });
      
      // Rest of content
      slide.addText(restContent.trim(), {
        x: 0.5,
        y: 2.7,
        w: '90%',
        h: 3.3,
        fontSize: 16,
        color: '333333',
        breakLine: true
      });
    } else {
      // Just add all content normally
      slide.addText(content.trim(), {
        x: 0.5,
        y: 1.6,
        w: '90%',
        h: 4.4,
        fontSize: 16,
        color: '333333',
        breakLine: true
      });
    }
  }
  
  // Add bullet points if exist
  if (bulletPoints.length > 0) {
    // Determine if we should use numbered or bulleted list based on format
    const isNumbered = bulletPoints.some(point => point.match(/^\d+\./));
    
    // Format points for presentation
    const textObjects = bulletPoints.map((point, index) => {
      return { 
        text: point,
        bullet: isNumbered ? { type: 'number', style: numberedListStyle(index + 1) } : { type: 'bullet' },
        color: '333333',
        breakLine: true
      };
    });
    
    slide.addText(textObjects, {
      x: 0.7,  // Indented slightly
      y: content && content.trim() ? 3.0 : 1.6,
      w: '85%', // Slightly narrower for indent effect
      h: 4.0,
      fontSize: 16,
      color: '333333',
      breakLine: true,
      bullet: isNumbered ? { type: 'number' } : { type: 'bullet' }
    });
  }
  
  // Add image placeholder if appropriate
  if (title.toLowerCase().includes('introduction') || 
      title.toLowerCase().includes('conclusion') ||
      slideNumber % 4 === 0) { // Every 4th slide gets an image
    
    // Use the appropriate image type based on the slide content
    let imagePath;
    if (title.toLowerCase().includes('introduction')) {
      imagePath = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 24 24" fill="none" stroke="' + theme.accentColor.replace('#', '') + '" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>';
    } else if (title.toLowerCase().includes('conclusion')) {
      imagePath = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 24 24" fill="none" stroke="' + theme.accentColor.replace('#', '') + '" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
    } else {
      // Generic image for other slides
      imagePath = 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 24 24" fill="none" stroke="' + theme.accentColor.replace('#', '') + '" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>';
    }
    
    // Only add image if we have space
    if ((!content || content.length < 300) && bulletPoints.length < 5) {
      slide.addImage({
        data: imagePath,
        x: 7.5,
        y: 1.5,
        w: 2,
        h: 2,
        transparency: 80 // Subtle
      });
    }
  }
}

/**
 * Helper function to generate numbered list styles
 */
function numberedListStyle(index: number): string {
  const styles = ['arabic', 'upperRoman', 'lowerRoman', 'upperLetter', 'lowerLetter'];
  return styles[index % styles.length];
}

/**
 * Helper function to adjust color brightness
 */
function adjustColor(color: string, amount: number): string {
  // Parse the color
  const r = parseInt(color.substring(0, 2), 16);
  const g = parseInt(color.substring(2, 4), 16);
  const b = parseInt(color.substring(4, 6), 16);
  
  // Adjust and clamp
  const newR = Math.min(255, Math.max(0, r + amount)).toString(16).padStart(2, '0');
  const newG = Math.min(255, Math.max(0, g + amount)).toString(16).padStart(2, '0');
  const newB = Math.min(255, Math.max(0, b + amount)).toString(16).padStart(2, '0');
  
  return `${newR}${newG}${newB}`;
}